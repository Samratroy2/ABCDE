{"ast":null,"code":"// backend/controllers/authController.js\n\nconst User = require(\"../models/User\");\nconst bcrypt = require(\"bcryptjs\");\nconst jwt = require(\"jsonwebtoken\");\nconst nodemailer = require(\"nodemailer\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nrequire(\"dotenv\").config();\n\n// JSON file paths\nconst patientFile = path.join(__dirname, \"../data/dummyPatientData.json\");\nconst doctorFile = path.join(__dirname, \"../data/dummyDoctorData.json\");\nconst pharmacistFile = path.join(__dirname, \"../data/dummyPharmacistData.json\");\n\n// Temporary OTP store (use DB/Redis in production)\nconst otpStore = {};\n\n// Helper: Generate JWT\nconst generateToken = user => {\n  return jwt.sign({\n    id: user._id\n  }, process.env.JWT_SECRET, {\n    expiresIn: \"7d\"\n  });\n};\n\n// Helper: Read/write JSON\nconst readFile = file => fs.existsSync(file) ? JSON.parse(fs.readFileSync(file)) : [];\nconst writeFile = (file, data) => fs.writeFileSync(file, JSON.stringify(data, null, 2));\n\n// ================== SIGNUP ==================\nconst signupUser = async (req, res) => {\n  try {\n    let {\n      name,\n      email,\n      password,\n      role\n    } = req.body;\n    if (!name || !email || !password) {\n      return res.status(400).json({\n        success: false,\n        message: \"All fields are required\"\n      });\n    }\n    const existingUser = await User.findOne({\n      email\n    });\n    if (existingUser) {\n      return res.status(400).json({\n        success: false,\n        message: \"Email already in use\"\n      });\n    }\n\n    // Make trysamrat1@gmail.com always admin\n    const finalRole = email === \"trysamrat1@gmail.com\" ? \"admin\" : role || \"patient\";\n\n    // Generate userId based on role + timestamp + random number\n    let userIdPrefix = \"user\";\n    if (finalRole === \"doctor\") userIdPrefix = \"doctor\";else if (finalRole === \"patient\") userIdPrefix = \"patient\";else if (finalRole === \"pharmacist\") userIdPrefix = \"pharmacist\";\n    const userId = userIdPrefix + Date.now() + Math.floor(Math.random() * 1000);\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const newUser = new User({\n      name,\n      email,\n      password: hashedPassword,\n      role: finalRole,\n      userId\n    });\n    await newUser.save();\n\n    // ---------------- Sync JSON ----------------\n    let jsonFile;\n    let jsonData = {};\n    if (finalRole === \"patient\") {\n      jsonFile = patientFile;\n      jsonData = {\n        name,\n        email,\n        age: req.body.age || null,\n        location: req.body.location || \"\",\n        contact: req.body.contact || \"\",\n        medicalHistory: req.body.medicalHistory || [],\n        medicines: [],\n        availability: []\n      };\n    } else if (finalRole === \"doctor\") {\n      jsonFile = doctorFile;\n      jsonData = {\n        name,\n        email,\n        age: req.body.age || null,\n        location: req.body.location || \"\",\n        contact: req.body.contact || \"\",\n        specialization: req.body.specialization || \"\",\n        experience: req.body.experience || 0,\n        patientsServed: req.body.patientsServed || 0,\n        rating: req.body.rating || 0,\n        availability: []\n      };\n    } else if (finalRole === \"pharmacist\") {\n      jsonFile = pharmacistFile;\n      jsonData = {\n        name,\n        email,\n        location: req.body.location || \"\",\n        pharmacyName: req.body.pharmacyName || \"\",\n        licenseNumber: req.body.licenseNumber || \"\",\n        address: req.body.address || \"\",\n        medicalHistory: [],\n        medicines: [],\n        availability: []\n      };\n    }\n    if (jsonFile) {\n      const arr = readFile(jsonFile);\n      arr.push(jsonData);\n      writeFile(jsonFile, arr);\n    }\n    const token = generateToken(newUser);\n    res.status(201).json({\n      success: true,\n      message: \"Signup successful\",\n      user: {\n        id: newUser._id,\n        name: newUser.name,\n        email: newUser.email,\n        role: newUser.role,\n        userId: newUser.userId\n      },\n      token\n    });\n  } catch (err) {\n    console.error(\"Signup error:\", err.message);\n    res.status(500).json({\n      success: false,\n      message: \"Server error\",\n      error: err.message\n    });\n  }\n};\n\n// ================== LOGIN ==================\nconst loginUser = async (req, res) => {\n  try {\n    const {\n      email,\n      password\n    } = req.body;\n    const user = await User.findOne({\n      email\n    });\n    if (!user) return res.status(400).json({\n      success: false,\n      message: \"Invalid credentials\"\n    });\n    const isMatch = await bcrypt.compare(password, user.password);\n    if (!isMatch) return res.status(400).json({\n      success: false,\n      message: \"Invalid credentials\"\n    });\n    const token = generateToken(user);\n    res.json({\n      success: true,\n      message: \"Login successful\",\n      user: {\n        id: user._id,\n        name: user.name,\n        email: user.email,\n        role: user.role,\n        userId: user.userId\n      },\n      token\n    });\n  } catch (err) {\n    console.error(\"Login error:\", err.message);\n    res.status(500).json({\n      success: false,\n      message: \"Server error\",\n      error: err.message\n    });\n  }\n};\n\n// ================== FORGOT PASSWORD ==================\nconst forgotPassword = async (req, res) => {\n  try {\n    const {\n      email\n    } = req.body;\n    const user = await User.findOne({\n      email\n    });\n    if (!user) return res.status(404).json({\n      success: false,\n      message: \"User not found with this email\"\n    });\n    const otp = Math.floor(100000 + Math.random() * 900000).toString();\n    otpStore[email] = {\n      otp,\n      expiresAt: Date.now() + 10 * 60 * 1000\n    }; // 10 min\n\n    const transporter = nodemailer.createTransport({\n      service: \"gmail\",\n      auth: {\n        user: process.env.EMAIL_USER,\n        pass: process.env.EMAIL_PASS\n      }\n    });\n    try {\n      await transporter.sendMail({\n        from: `\"Healthcare App\" <${process.env.EMAIL_USER}>`,\n        to: email,\n        subject: \"Password Reset OTP\",\n        text: `Your OTP for password reset is: ${otp}. It will expire in 10 minutes.`\n      });\n      return res.json({\n        success: true,\n        message: \"OTP sent to email\"\n      });\n    } catch (mailError) {\n      console.log(`OTP for ${email}: ${otp}`);\n      return res.json({\n        success: true,\n        message: \"OTP generated (check console in dev mode).\"\n      });\n    }\n  } catch (err) {\n    console.error(\"Forgot password error:\", err.message);\n    res.status(500).json({\n      success: false,\n      message: \"Server error\",\n      error: err.message\n    });\n  }\n};\n\n// ================== RESET PASSWORD ==================\nconst resetPassword = async (req, res) => {\n  try {\n    const {\n      email,\n      otp,\n      newPassword\n    } = req.body;\n    const entry = otpStore[email];\n    if (!entry || entry.otp !== otp || entry.expiresAt < Date.now()) {\n      return res.status(400).json({\n        success: false,\n        message: \"Invalid or expired OTP\"\n      });\n    }\n    const user = await User.findOne({\n      email\n    });\n    if (!user) return res.status(404).json({\n      success: false,\n      message: \"User not found with this email\"\n    });\n    user.password = await bcrypt.hash(newPassword, 10);\n    await user.save();\n    delete otpStore[email];\n    res.json({\n      success: true,\n      message: \"Password reset successful\"\n    });\n  } catch (err) {\n    console.error(\"Reset password error:\", err.message);\n    res.status(500).json({\n      success: false,\n      message: \"Server error\",\n      error: err.message\n    });\n  }\n};\nmodule.exports = {\n  signupUser,\n  loginUser,\n  forgotPassword,\n  resetPassword\n};","map":{"version":3,"names":["User","require","bcrypt","jwt","nodemailer","fs","path","config","patientFile","join","__dirname","doctorFile","pharmacistFile","otpStore","generateToken","user","sign","id","_id","process","env","JWT_SECRET","expiresIn","readFile","file","existsSync","JSON","parse","readFileSync","writeFile","data","writeFileSync","stringify","signupUser","req","res","name","email","password","role","body","status","json","success","message","existingUser","findOne","finalRole","userIdPrefix","userId","Date","now","Math","floor","random","hashedPassword","hash","newUser","save","jsonFile","jsonData","age","location","contact","medicalHistory","medicines","availability","specialization","experience","patientsServed","rating","pharmacyName","licenseNumber","address","arr","push","token","err","console","error","loginUser","isMatch","compare","forgotPassword","otp","toString","expiresAt","transporter","createTransport","service","auth","EMAIL_USER","pass","EMAIL_PASS","sendMail","from","to","subject","text","mailError","log","resetPassword","newPassword","entry","module","exports"],"sources":["C:/Users/SAMRAT ROY/Downloads/new 1/frontend/src/contexts/AuthContext.jsx"],"sourcesContent":["// backend/controllers/authController.js\r\n\r\nconst User = require(\"../models/User\");\r\nconst bcrypt = require(\"bcryptjs\");\r\nconst jwt = require(\"jsonwebtoken\");\r\nconst nodemailer = require(\"nodemailer\");\r\nconst fs = require(\"fs\");\r\nconst path = require(\"path\");\r\nrequire(\"dotenv\").config();\r\n\r\n// JSON file paths\r\nconst patientFile = path.join(__dirname, \"../data/dummyPatientData.json\");\r\nconst doctorFile = path.join(__dirname, \"../data/dummyDoctorData.json\");\r\nconst pharmacistFile = path.join(__dirname, \"../data/dummyPharmacistData.json\");\r\n\r\n// Temporary OTP store (use DB/Redis in production)\r\nconst otpStore = {};\r\n\r\n// Helper: Generate JWT\r\nconst generateToken = (user) => {\r\n  return jwt.sign({ id: user._id }, process.env.JWT_SECRET, {\r\n    expiresIn: \"7d\",\r\n  });\r\n};\r\n\r\n// Helper: Read/write JSON\r\nconst readFile = (file) => (fs.existsSync(file) ? JSON.parse(fs.readFileSync(file)) : []);\r\nconst writeFile = (file, data) => fs.writeFileSync(file, JSON.stringify(data, null, 2));\r\n\r\n// ================== SIGNUP ==================\r\nconst signupUser = async (req, res) => {\r\n  try {\r\n    let { name, email, password, role } = req.body;\r\n\r\n    if (!name || !email || !password) {\r\n      return res.status(400).json({ success: false, message: \"All fields are required\" });\r\n    }\r\n\r\n    const existingUser = await User.findOne({ email });\r\n    if (existingUser) {\r\n      return res.status(400).json({ success: false, message: \"Email already in use\" });\r\n    }\r\n\r\n    // Make trysamrat1@gmail.com always admin\r\n    const finalRole = email === \"trysamrat1@gmail.com\" ? \"admin\" : role || \"patient\";\r\n\r\n    // Generate userId based on role + timestamp + random number\r\n    let userIdPrefix = \"user\";\r\n    if (finalRole === \"doctor\") userIdPrefix = \"doctor\";\r\n    else if (finalRole === \"patient\") userIdPrefix = \"patient\";\r\n    else if (finalRole === \"pharmacist\") userIdPrefix = \"pharmacist\";\r\n    const userId = userIdPrefix + Date.now() + Math.floor(Math.random() * 1000);\r\n\r\n    const hashedPassword = await bcrypt.hash(password, 10);\r\n    const newUser = new User({\r\n      name,\r\n      email,\r\n      password: hashedPassword,\r\n      role: finalRole,\r\n      userId,\r\n    });\r\n\r\n    await newUser.save();\r\n\r\n    // ---------------- Sync JSON ----------------\r\n    let jsonFile;\r\n    let jsonData = {};\r\n    if (finalRole === \"patient\") {\r\n      jsonFile = patientFile;\r\n      jsonData = {\r\n        name,\r\n        email,\r\n        age: req.body.age || null,\r\n        location: req.body.location || \"\",\r\n        contact: req.body.contact || \"\",\r\n        medicalHistory: req.body.medicalHistory || [],\r\n        medicines: [],\r\n        availability: [],\r\n      };\r\n    } else if (finalRole === \"doctor\") {\r\n      jsonFile = doctorFile;\r\n      jsonData = {\r\n        name,\r\n        email,\r\n        age: req.body.age || null,\r\n        location: req.body.location || \"\",\r\n        contact: req.body.contact || \"\",\r\n        specialization: req.body.specialization || \"\",\r\n        experience: req.body.experience || 0,\r\n        patientsServed: req.body.patientsServed || 0,\r\n        rating: req.body.rating || 0,\r\n        availability: [],\r\n      };\r\n    } else if (finalRole === \"pharmacist\") {\r\n      jsonFile = pharmacistFile;\r\n      jsonData = {\r\n        name,\r\n        email,\r\n        location: req.body.location || \"\",\r\n        pharmacyName: req.body.pharmacyName || \"\",\r\n        licenseNumber: req.body.licenseNumber || \"\",\r\n        address: req.body.address || \"\",\r\n        medicalHistory: [],\r\n        medicines: [],\r\n        availability: [],\r\n      };\r\n    }\r\n\r\n    if (jsonFile) {\r\n      const arr = readFile(jsonFile);\r\n      arr.push(jsonData);\r\n      writeFile(jsonFile, arr);\r\n    }\r\n\r\n    const token = generateToken(newUser);\r\n\r\n    res.status(201).json({\r\n      success: true,\r\n      message: \"Signup successful\",\r\n      user: {\r\n        id: newUser._id,\r\n        name: newUser.name,\r\n        email: newUser.email,\r\n        role: newUser.role,\r\n        userId: newUser.userId,\r\n      },\r\n      token,\r\n    });\r\n  } catch (err) {\r\n    console.error(\"Signup error:\", err.message);\r\n    res.status(500).json({ success: false, message: \"Server error\", error: err.message });\r\n  }\r\n};\r\n\r\n// ================== LOGIN ==================\r\nconst loginUser = async (req, res) => {\r\n  try {\r\n    const { email, password } = req.body;\r\n\r\n    const user = await User.findOne({ email });\r\n    if (!user) return res.status(400).json({ success: false, message: \"Invalid credentials\" });\r\n\r\n    const isMatch = await bcrypt.compare(password, user.password);\r\n    if (!isMatch)\r\n      return res.status(400).json({ success: false, message: \"Invalid credentials\" });\r\n\r\n    const token = generateToken(user);\r\n\r\n    res.json({\r\n      success: true,\r\n      message: \"Login successful\",\r\n      user: {\r\n        id: user._id,\r\n        name: user.name,\r\n        email: user.email,\r\n        role: user.role,\r\n        userId: user.userId,\r\n      },\r\n      token,\r\n    });\r\n  } catch (err) {\r\n    console.error(\"Login error:\", err.message);\r\n    res.status(500).json({ success: false, message: \"Server error\", error: err.message });\r\n  }\r\n};\r\n\r\n// ================== FORGOT PASSWORD ==================\r\nconst forgotPassword = async (req, res) => {\r\n  try {\r\n    const { email } = req.body;\r\n    const user = await User.findOne({ email });\r\n    if (!user)\r\n      return res.status(404).json({ success: false, message: \"User not found with this email\" });\r\n\r\n    const otp = Math.floor(100000 + Math.random() * 900000).toString();\r\n    otpStore[email] = { otp, expiresAt: Date.now() + 10 * 60 * 1000 }; // 10 min\r\n\r\n    const transporter = nodemailer.createTransport({\r\n      service: \"gmail\",\r\n      auth: { user: process.env.EMAIL_USER, pass: process.env.EMAIL_PASS },\r\n    });\r\n\r\n    try {\r\n      await transporter.sendMail({\r\n        from: `\"Healthcare App\" <${process.env.EMAIL_USER}>`,\r\n        to: email,\r\n        subject: \"Password Reset OTP\",\r\n        text: `Your OTP for password reset is: ${otp}. It will expire in 10 minutes.`,\r\n      });\r\n      return res.json({ success: true, message: \"OTP sent to email\" });\r\n    } catch (mailError) {\r\n      console.log(`OTP for ${email}: ${otp}`);\r\n      return res.json({\r\n        success: true,\r\n        message: \"OTP generated (check console in dev mode).\",\r\n      });\r\n    }\r\n  } catch (err) {\r\n    console.error(\"Forgot password error:\", err.message);\r\n    res.status(500).json({ success: false, message: \"Server error\", error: err.message });\r\n  }\r\n};\r\n\r\n// ================== RESET PASSWORD ==================\r\nconst resetPassword = async (req, res) => {\r\n  try {\r\n    const { email, otp, newPassword } = req.body;\r\n    const entry = otpStore[email];\r\n\r\n    if (!entry || entry.otp !== otp || entry.expiresAt < Date.now()) {\r\n      return res.status(400).json({ success: false, message: \"Invalid or expired OTP\" });\r\n    }\r\n\r\n    const user = await User.findOne({ email });\r\n    if (!user)\r\n      return res.status(404).json({ success: false, message: \"User not found with this email\" });\r\n\r\n    user.password = await bcrypt.hash(newPassword, 10);\r\n    await user.save();\r\n\r\n    delete otpStore[email];\r\n\r\n    res.json({ success: true, message: \"Password reset successful\" });\r\n  } catch (err) {\r\n    console.error(\"Reset password error:\", err.message);\r\n    res.status(500).json({ success: false, message: \"Server error\", error: err.message });\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  signupUser,\r\n  loginUser,\r\n  forgotPassword,\r\n  resetPassword,\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}